/*
⣿⣿⣿⣿⣿⣿⡷⣯⢿⣿⣷⣻⢯⣿⡽⣻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⠸⣿⣿⣆⠹⣿⣿⢾⣟⣯⣿⣿⣿⣿⣿⣿⣽⣻⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣻⣽⡿⣿⣎⠙⣿⣞⣷⡌⢻⣟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣿⣿⡄⠹⣿⣿⡆⠻⣿⣟⣯⡿⣽⡿⣿⣿⣿⣿⣽⡷⣯⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣟⣷⣿⣿⣿⡀⠹⣟⣾⣟⣆⠹⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢠⡘⣿⣿⡄⠉⢿⣿⣽⡷⣿⣻⣿⣿⣿⣿⡝⣷⣯⢿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣯⢿⣾⢿⣿⡄⢄⠘⢿⣞⡿⣧⡈⢷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢸⣧⠘⣿⣷⠈⣦⠙⢿⣽⣷⣻⣽⣿⣿⣿⣿⣌⢿⣯⢿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣟⣯⣿⢿⣿⡆⢸⡷⡈⢻⡽⣷⡷⡄⠻⣽⣿⣿⡿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣏⢰⣯⢷⠈⣿⡆⢹⢷⡌⠻⡾⢋⣱⣯⣿⣿⣿⣿⡆⢻⡿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⡎⣿⢾⡿⣿⡆⢸⣽⢻⣄⠹⣷⣟⣿⣄⠹⣟⣿⣿⣟⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⢸⣯⣟⣧⠘⣷⠈⡯⠛⢀⡐⢾⣟⣷⣻⣿⣿⣿⡿⡌⢿⣻⣿⣿
⣿⣿⣿⣿⣿⣿⣧⢸⡿⣟⣿⡇⢸⣯⣟⣮⢧⡈⢿⣞⡿⣦⠘⠏⣹⣿⣽⢿⣿⣿⣿⣿⣯⣿⣿⣿⡇⢸⣿⣿⣾⡆⠹⢀⣠⣾⣟⣷⡈⢿⣞⣯⢿⣿⣿⣿⢷⠘⣯⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡈⣿⢿⣽⡇⠘⠛⠛⠛⠓⠓⠈⠛⠛⠟⠇⢀⢿⣻⣿⣯⢿⣿⣿⣿⣷⢿⣿⣿⠁⣾⣿⣿⣿⣧⡄⠇⣹⣿⣾⣯⣿⡄⠻⣽⣯⢿⣻⣿⣿⡇⢹⣾⣿
⣿⣿⣿⣿⣿⣿⣿⡇⢹⣿⡽⡇⢸⣿⣿⣿⣿⣿⣞⣆⠰⣶⣶⡄⢀⢻⡿⣯⣿⡽⣿⣿⣿⢯⣟⡿⢀⣿⣿⣿⣿⣿⣧⠐⣸⣿⣿⣷⣿⣿⣆⠹⣯⣿⣻⣿⣿⣿⢀⣿⢿
⣿⣿⣿⣿⣿⣿⣿⣿⠘⣯⡿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣧⡈⢿⣳⠘⡄⠻⣿⢾⣽⣟⡿⣿⢯⣿⡇⢸⣿⣿⣿⣿⣿⣿⡀⢾⣿⣿⣿⣿⣿⣿⣆⠹⣾⣷⣻⣿⡿⡇⢸⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡇⢹⣿⠇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠻⡇⢹⣆⠹⣟⣾⣽⣻⣟⣿⣽⠁⣾⣿⣿⣿⣿⣿⣿⣇⣿⣿⠿⠛⠛⠉⠙⠋⢀⠁⢘⣯⣿⣿⣧⠘⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⡈⣿⡃⢼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡙⠌⣿⣆⠘⣿⣞⡿⣞⡿⡞⢠⣿⣿⣿⣿⣿⡿⠛⠉⠁⢀⣀⣠⣤⣤⣶⣶⣶⡆⢻⣽⣞⡿⣷⠈⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠘⠁⠉⠉⠉⠉⠉⠉⠉⠉⠉⠙⠛⠛⢿⣄⢻⣿⣧⠘⢯⣟⡿⣽⠁⣾⣿⣿⣿⣿⣿⡃⢀⢀⠘⠛⠿⢿⣻⣟⣯⣽⣻⣵⡀⢿⣯⣟⣿⢀⣿
⣿⣿⣿⣟⣿⣿⣿⣿⣶⣶⡆⢀⣿⣾⣿⣾⣷⣿⣶⠿⠚⠉⢀⢀⣤⣿⣷⣿⣿⣷⡈⢿⣻⢃⣼⣿⣿⣿⣿⣻⣿⣿⣿⡶⣦⣤⣄⣀⡀⠉⠛⠛⠷⣯⣳⠈⣾⡽⣾⢀⣿
⣿⢿⣿⣿⣻⣿⣿⣿⣿⣿⡿⠐⣿⣿⣿⣿⠿⠋⠁⢀⢀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣌⣥⣾⡿⣿⣿⣷⣿⣿⢿⣷⣿⣿⣟⣾⣽⣳⢯⣟⣶⣦⣤⡾⣟⣦⠘⣿⢾⡁⢺
⣿⣻⣿⣿⡷⣿⣿⣿⣿⣿⡗⣦⠸⡿⠋⠁⢀⢀⣠⣴⢿⣿⣽⣻⢽⣾⣟⣷⣿⣟⣿⣿⣿⣳⠿⣵⣧⣼⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣽⣳⣯⣿⣿⣿⣽⢀⢷⣻⠄⠘
⣿⢷⣻⣿⣿⣷⣻⣿⣿⣿⡷⠛⣁⢀⣀⣤⣶⣿⣛⡿⣿⣮⣽⡻⣿⣮⣽⣻⢯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⢀⢸⣿⢀⡆
⠸⣟⣯⣿⣿⣷⢿⣽⣿⣿⣷⣿⣷⣆⠹⣿⣶⣯⠿⣿⣶⣟⣻⢿⣷⣽⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⣯⣟⢀⡇
⣇⠹⣟⣾⣻⣿⣿⢾⡽⣿⣿⣿⣿⣿⣆⢹⣶⣿⣻⣷⣯⣟⣿⣿⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢀⡿⡇⢸⡇
⣿⣆⠹⣷⡻⣽⣿⣯⢿⣽⣻⣿⣿⣿⣿⣆⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⢸⣿⠇⣼⡇
⡙⠾⣆⠹⣿⣦⠛⣿⢯⣷⢿⡽⣿⣿⣿⣿⣆⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠎⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⢀⣿⣾⣣⡿⡇
⣿⣷⡌⢦⠙⣿⣿⣌⠻⣽⢯⣿⣽⣻⣿⣿⣿⣧⠩⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⢰⢣⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⢀⢀⢿⣞⣷⢿⡇
⣿⣽⣆⠹⣧⠘⣿⣿⡷⣌⠙⢷⣯⡷⣟⣿⣿⣿⣷⡀⡹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣈⠃⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢀⣴⡧⢀⠸⣿⡽⣿⢀
⢻⣽⣿⡄⢻⣷⡈⢿⣿⣿⢧⢀⠙⢿⣻⡾⣽⣻⣿⣿⣄⠌⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⢁⣰⣾⣟⡿⢀⡄⢿⣟⣿⢀
⡄⢿⣿⣷⢀⠹⣟⣆⠻⣿⣿⣆⢀⣀⠉⠻⣿⡽⣯⣿⣿⣷⣈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⢀⣠⠘⣯⣷⣿⡟⢀⢆⠸⣿⡟⢸
⣷⡈⢿⣿⣇⢱⡘⢿⣷⣬⣙⠿⣧⠘⣆⢀⠈⠻⣷⣟⣾⢿⣿⣆⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⣠⡞⢡⣿⢀⣿⣿⣿⠇⡄⢸⡄⢻⡇⣼
⣿⣷⡈⢿⣿⡆⢣⡀⠙⢾⣟⣿⣿⣷⡈⠂⠘⣦⡈⠿⣯⣿⢾⣿⣆⠙⠻⠿⠿⠿⠿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⢋⣠⣾⡟⢠⣿⣿⢀⣿⣿⡟⢠⣿⢈⣧⠘⢠⣿
⣿⣿⣿⣄⠻⣿⡄⢳⡄⢆⡙⠾⣽⣿⣿⣆⡀⢹⡷⣄⠙⢿⣿⡾⣿⣆⢀⡀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⣀⣠⣴⡿⣯⠏⣠⣿⣿⡏⢸⣿⡿⢁⣿⣿⢀⣿⠆⢸⣿
⣿⣿⣿⣿⣦⡙⣿⣆⢻⡌⢿⣶⢤⣉⣙⣿⣷⡀⠙⠽⠷⠄⠹⣿⣟⣿⣆⢙⣋⣤⣤⣤⣄⣀⢀⢀⢀⢀⣾⣿⣟⡷⣯⡿⢃⣼⣿⣿⣿⠇⣼⡟⣡⣿⣿⣿⢀⡿⢠⠈⣿
⣿⣿⣿⣿⣿⣷⣮⣿⣿⣿⡌⠁⢤⣤⣤⣤⣬⣭⣴⣶⣶⣶⣆⠈⢻⣿⣿⣆⢻⣿⣿⣿⣿⣿⣿⣷⣶⣤⣌⣉⡘⠛⠻⠶⣿⣿⣿⣿⡟⣰⣫⣴⣿⣿⣿⣿⠄⣷⣿⣿⣿
*/

#include<bits/stdc++.h>
using namespace std;

#define int long long 

class Node {
public:	
	int key;
	int val;
	Node *next;
	Node *prev;

	Node() {
		this -> next = NULL;
		this -> prev = NULL;
	}
	Node(int key, int val) {
		this -> key = key;
		this -> val = val;
		this -> prev = NULL;
		this -> next = NULL;
	}
};

class FreqNode {
public:
	int freqOfNode;
	int key;
	int val;
	FreqNode *next;
	FreqNode *prev;
	FreqNode(int key, int val) {
		this -> key = key;
		this -> val = val;
		this -> freqOfNode = 1;
		this -> next = NULL;
		this -> prev = NULL;
	}
};


// Genric Doubly LinkedList
template<class NodeType>
class DLList {
public:
	NodeType* head;
	NodeType* tail;
	int sizeOfDLL;
	DLList() {
		this -> head = new NodeType(-1, -1);
		this -> tail = new NodeType(-1, -1);
		this -> head -> next = this -> tail;
		this -> tail -> prev = this -> head;
		this -> sizeOfDLL = 0;
	}
	void addNodeAtFront(NodeType* curNode) {
		NodeType* tempNode = this -> head -> next;
		this -> head -> next = curNode;
		curNode -> prev = this -> head;
		curNode -> next = tempNode;
		tempNode -> prev = curNode;
		this -> sizeOfDLL += 1;
	}
	void removeNode(NodeType* curNode) {
		NodeType* tempPrevNode = curNode -> prev;
		NodeType* tempNextNode = curNode -> next;
		tempPrevNode -> next = tempNextNode;
		tempNextNode -> prev = tempPrevNode;
		this -> sizeOfDLL -= 1;
	}
	bool isEmpty() {
		return this -> sizeOfDLL == 0;
	}
};



class Cache {
public:
	virtual int get(int key) = 0;
	virtual void put(int key, int val) = 0;
};

class LRU : public Cache {

	unordered_map<int, Node*> keyToNodeMap;
	DLList<Node> *list;
	int cap;
public:
	LRU() {
		this -> list = new DLList<Node>();
	}
	LRU(int cap) {
		this -> cap = cap;
		this -> list = new DLList<Node>();
	}
	int get(int key) override {
		// If key doesn't exists in LRU
		if(this -> keyToNodeMap.find(key) == this -> keyToNodeMap.end()) return -1;

		// If it exists operations to be done :
		// - Remove from its postion in the list and LRU keyToNodeMap.
		// - Add node after head of list and update the position in LRU keyToNodeMap.
		// - Return the value associated with the key.
		Node *curNode = this -> keyToNodeMap[key];
		this -> list -> removeNode(curNode);
		this -> list -> addNodeAtFront(curNode);
		// We can also do keyToNodeMap.erase(key) then update the same 
		// so we can update it without erasing too..
		this -> keyToNodeMap[key] = this -> list -> head -> next;
		return curNode -> val;
	}
	void put(int key, int val) override {
		// If key exists in LRU
		if(this -> keyToNodeMap.find(key) != this -> keyToNodeMap.end()) {
			Node *curNode = this -> keyToNodeMap[key];
			this -> list -> removeNode(curNode);
		} else if(cap == this -> keyToNodeMap.size()) {
			this -> keyToNodeMap.erase(this -> list -> tail -> prev -> key);
			this -> list -> removeNode(this -> list -> tail -> prev);
		}
		this -> list -> addNodeAtFront(new Node(key, val));
		this -> keyToNodeMap[key] = this -> list -> head -> next;
	}
};


// Least Frequently Used Cache (LFU) 
class LFU : public Cache {

public:

	unordered_map<int, DLList<FreqNode>*> freqMap; // Freq -> DLL 
	unordered_map<int, FreqNode*> keyToNodeMap;    // Key -> Node
	int maxSize;
	int minFreq;

	LFU(int cap) {
		this -> maxSize = cap;
		this -> minFreq = 0;
	}

	// Updation of given Node
	void updationOfNode(FreqNode* curNode) {

		// Operations to be done : 
		// - Remove from the keyToNodeMap.
		// - Remove form the freqMap.
		// - Check for updation of minFreq.
		// - New DLL creation if DLL for updatedFreqOfNode doesn't exists or exists.
		// - Updation in freqMap.
		// - Updation in keyToNodeMap.

		this -> keyToNodeMap.erase(curNode -> key);
		this -> freqMap[curNode -> freqOfNode] -> removeNode(curNode);

		// Checking the DLL of minFreq and updating if size == 0
		if(curNode -> freqOfNode == minFreq && this -> freqMap[this -> minFreq] -> isEmpty()) {
			this -> freqMap.erase(minFreq);
			this -> minFreq++;
		}
		DLList<FreqNode>* newFreqList = new DLList<FreqNode>();

		int updatedFreqOfNode = curNode -> freqOfNode + 1;
		curNode -> freqOfNode = updatedFreqOfNode;

		// Check if the updatedFreqOfNode exists or not
		if(this -> freqMap.find(updatedFreqOfNode) != this -> freqMap.end()) {
			newFreqList = this -> freqMap[curNode -> freqOfNode];
		}
		newFreqList -> addNodeAtFront(curNode);

		// Updation
		this -> freqMap[updatedFreqOfNode] = newFreqList;
		this -> keyToNodeMap[curNode -> key] = newFreqList -> head -> next;
	}
	int get(int key) override {
		// If key doesn't exists in LFU
		if(this -> keyToNodeMap.find(key) == this -> keyToNodeMap.end()) return -1;
		FreqNode* curNode = this -> keyToNodeMap[key];
		this -> updationOfNode(curNode);
		return curNode -> val;
	}
	void put(int key, int val) override {
		if(this -> maxSize == 0) return;

		// If key already exists in the LFU
		if(this -> keyToNodeMap.find(key) != this -> keyToNodeMap.end()) {
			FreqNode* curNode = this -> keyToNodeMap[key];
			// Updating the current key's node's val;
			curNode -> val = val;
			updationOfNode(curNode);
			return;
		}
		// If size == maxSize remove the least freq node from tail -> prev
		if(maxSize == this -> keyToNodeMap.size()) {
			DLList<FreqNode>* list = this -> freqMap[minFreq];
			this -> keyToNodeMap.erase(list -> tail -> prev -> key);
			list -> removeNode(list -> tail -> prev);
			if(list -> isEmpty()) this -> freqMap.erase(minFreq);
		}

		// For new element minFreq = 1.
		minFreq = 1;
		DLList<FreqNode>* list = new DLList<FreqNode>();
		if(this -> freqMap.find(minFreq) != this -> freqMap.end()) {
			list = this -> freqMap[minFreq];
		}
		list -> addNodeAtFront(new FreqNode(key, val));
		this -> freqMap[minFreq] = list;
		this -> keyToNodeMap[key] = this -> freqMap[minFreq] -> head -> next;
	}
};

signed main() {
	int t = 1;
	while(t--) {
		LFU* lfu = new LFU(2);
		lfu -> put(1, 1);
		lfu -> put(2, 2);
		lfu -> put(1, 3);
		cout << lfu -> get(1);
		lfu -> put(2, 4);
		cout << lfu -> get(2);
	}
}