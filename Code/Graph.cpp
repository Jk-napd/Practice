/*
⣿⣿⣿⣿⣿⣿⡷⣯⢿⣿⣷⣻⢯⣿⡽⣻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⠸⣿⣿⣆⠹⣿⣿⢾⣟⣯⣿⣿⣿⣿⣿⣿⣽⣻⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣻⣽⡿⣿⣎⠙⣿⣞⣷⡌⢻⣟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣿⣿⡄⠹⣿⣿⡆⠻⣿⣟⣯⡿⣽⡿⣿⣿⣿⣿⣽⡷⣯⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣟⣷⣿⣿⣿⡀⠹⣟⣾⣟⣆⠹⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢠⡘⣿⣿⡄⠉⢿⣿⣽⡷⣿⣻⣿⣿⣿⣿⡝⣷⣯⢿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣯⢿⣾⢿⣿⡄⢄⠘⢿⣞⡿⣧⡈⢷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢸⣧⠘⣿⣷⠈⣦⠙⢿⣽⣷⣻⣽⣿⣿⣿⣿⣌⢿⣯⢿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣟⣯⣿⢿⣿⡆⢸⡷⡈⢻⡽⣷⡷⡄⠻⣽⣿⣿⡿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣏⢰⣯⢷⠈⣿⡆⢹⢷⡌⠻⡾⢋⣱⣯⣿⣿⣿⣿⡆⢻⡿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⡎⣿⢾⡿⣿⡆⢸⣽⢻⣄⠹⣷⣟⣿⣄⠹⣟⣿⣿⣟⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⢸⣯⣟⣧⠘⣷⠈⡯⠛⢀⡐⢾⣟⣷⣻⣿⣿⣿⡿⡌⢿⣻⣿⣿
⣿⣿⣿⣿⣿⣿⣧⢸⡿⣟⣿⡇⢸⣯⣟⣮⢧⡈⢿⣞⡿⣦⠘⠏⣹⣿⣽⢿⣿⣿⣿⣿⣯⣿⣿⣿⡇⢸⣿⣿⣾⡆⠹⢀⣠⣾⣟⣷⡈⢿⣞⣯⢿⣿⣿⣿⢷⠘⣯⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡈⣿⢿⣽⡇⠘⠛⠛⠛⠓⠓⠈⠛⠛⠟⠇⢀⢿⣻⣿⣯⢿⣿⣿⣿⣷⢿⣿⣿⠁⣾⣿⣿⣿⣧⡄⠇⣹⣿⣾⣯⣿⡄⠻⣽⣯⢿⣻⣿⣿⡇⢹⣾⣿
⣿⣿⣿⣿⣿⣿⣿⡇⢹⣿⡽⡇⢸⣿⣿⣿⣿⣿⣞⣆⠰⣶⣶⡄⢀⢻⡿⣯⣿⡽⣿⣿⣿⢯⣟⡿⢀⣿⣿⣿⣿⣿⣧⠐⣸⣿⣿⣷⣿⣿⣆⠹⣯⣿⣻⣿⣿⣿⢀⣿⢿
⣿⣿⣿⣿⣿⣿⣿⣿⠘⣯⡿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣧⡈⢿⣳⠘⡄⠻⣿⢾⣽⣟⡿⣿⢯⣿⡇⢸⣿⣿⣿⣿⣿⣿⡀⢾⣿⣿⣿⣿⣿⣿⣆⠹⣾⣷⣻⣿⡿⡇⢸⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡇⢹⣿⠇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠻⡇⢹⣆⠹⣟⣾⣽⣻⣟⣿⣽⠁⣾⣿⣿⣿⣿⣿⣿⣇⣿⣿⠿⠛⠛⠉⠙⠋⢀⠁⢘⣯⣿⣿⣧⠘⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⡈⣿⡃⢼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡙⠌⣿⣆⠘⣿⣞⡿⣞⡿⡞⢠⣿⣿⣿⣿⣿⡿⠛⠉⠁⢀⣀⣠⣤⣤⣶⣶⣶⡆⢻⣽⣞⡿⣷⠈⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠘⠁⠉⠉⠉⠉⠉⠉⠉⠉⠉⠙⠛⠛⢿⣄⢻⣿⣧⠘⢯⣟⡿⣽⠁⣾⣿⣿⣿⣿⣿⡃⢀⢀⠘⠛⠿⢿⣻⣟⣯⣽⣻⣵⡀⢿⣯⣟⣿⢀⣿
⣿⣿⣿⣟⣿⣿⣿⣿⣶⣶⡆⢀⣿⣾⣿⣾⣷⣿⣶⠿⠚⠉⢀⢀⣤⣿⣷⣿⣿⣷⡈⢿⣻⢃⣼⣿⣿⣿⣿⣻⣿⣿⣿⡶⣦⣤⣄⣀⡀⠉⠛⠛⠷⣯⣳⠈⣾⡽⣾⢀⣿
⣿⢿⣿⣿⣻⣿⣿⣿⣿⣿⡿⠐⣿⣿⣿⣿⠿⠋⠁⢀⢀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣌⣥⣾⡿⣿⣿⣷⣿⣿⢿⣷⣿⣿⣟⣾⣽⣳⢯⣟⣶⣦⣤⡾⣟⣦⠘⣿⢾⡁⢺
⣿⣻⣿⣿⡷⣿⣿⣿⣿⣿⡗⣦⠸⡿⠋⠁⢀⢀⣠⣴⢿⣿⣽⣻⢽⣾⣟⣷⣿⣟⣿⣿⣿⣳⠿⣵⣧⣼⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣽⣳⣯⣿⣿⣿⣽⢀⢷⣻⠄⠘
⣿⢷⣻⣿⣿⣷⣻⣿⣿⣿⡷⠛⣁⢀⣀⣤⣶⣿⣛⡿⣿⣮⣽⡻⣿⣮⣽⣻⢯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⢀⢸⣿⢀⡆
⠸⣟⣯⣿⣿⣷⢿⣽⣿⣿⣷⣿⣷⣆⠹⣿⣶⣯⠿⣿⣶⣟⣻⢿⣷⣽⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⣯⣟⢀⡇
⣇⠹⣟⣾⣻⣿⣿⢾⡽⣿⣿⣿⣿⣿⣆⢹⣶⣿⣻⣷⣯⣟⣿⣿⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢀⡿⡇⢸⡇
⣿⣆⠹⣷⡻⣽⣿⣯⢿⣽⣻⣿⣿⣿⣿⣆⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⢸⣿⠇⣼⡇
⡙⠾⣆⠹⣿⣦⠛⣿⢯⣷⢿⡽⣿⣿⣿⣿⣆⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠎⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⢀⣿⣾⣣⡿⡇
⣿⣷⡌⢦⠙⣿⣿⣌⠻⣽⢯⣿⣽⣻⣿⣿⣿⣧⠩⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⢰⢣⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⢀⢀⢿⣞⣷⢿⡇
⣿⣽⣆⠹⣧⠘⣿⣿⡷⣌⠙⢷⣯⡷⣟⣿⣿⣿⣷⡀⡹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣈⠃⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢀⣴⡧⢀⠸⣿⡽⣿⢀
⢻⣽⣿⡄⢻⣷⡈⢿⣿⣿⢧⢀⠙⢿⣻⡾⣽⣻⣿⣿⣄⠌⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⢁⣰⣾⣟⡿⢀⡄⢿⣟⣿⢀
⡄⢿⣿⣷⢀⠹⣟⣆⠻⣿⣿⣆⢀⣀⠉⠻⣿⡽⣯⣿⣿⣷⣈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⢀⣠⠘⣯⣷⣿⡟⢀⢆⠸⣿⡟⢸
⣷⡈⢿⣿⣇⢱⡘⢿⣷⣬⣙⠿⣧⠘⣆⢀⠈⠻⣷⣟⣾⢿⣿⣆⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⣠⡞⢡⣿⢀⣿⣿⣿⠇⡄⢸⡄⢻⡇⣼
⣿⣷⡈⢿⣿⡆⢣⡀⠙⢾⣟⣿⣿⣷⡈⠂⠘⣦⡈⠿⣯⣿⢾⣿⣆⠙⠻⠿⠿⠿⠿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⢋⣠⣾⡟⢠⣿⣿⢀⣿⣿⡟⢠⣿⢈⣧⠘⢠⣿
⣿⣿⣿⣄⠻⣿⡄⢳⡄⢆⡙⠾⣽⣿⣿⣆⡀⢹⡷⣄⠙⢿⣿⡾⣿⣆⢀⡀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⣀⣠⣴⡿⣯⠏⣠⣿⣿⡏⢸⣿⡿⢁⣿⣿⢀⣿⠆⢸⣿
⣿⣿⣿⣿⣦⡙⣿⣆⢻⡌⢿⣶⢤⣉⣙⣿⣷⡀⠙⠽⠷⠄⠹⣿⣟⣿⣆⢙⣋⣤⣤⣤⣄⣀⢀⢀⢀⢀⣾⣿⣟⡷⣯⡿⢃⣼⣿⣿⣿⠇⣼⡟⣡⣿⣿⣿⢀⡿⢠⠈⣿
⣿⣿⣿⣿⣿⣷⣮⣿⣿⣿⡌⠁⢤⣤⣤⣤⣬⣭⣴⣶⣶⣶⣆⠈⢻⣿⣿⣆⢻⣿⣿⣿⣿⣿⣿⣷⣶⣤⣌⣉⡘⠛⠻⠶⣿⣿⣿⣿⡟⣰⣫⣴⣿⣿⣿⣿⠄⣷⣿⣿⣿
*/

#include<bits/stdc++.h>
using namespace std;

#define int long long 

const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, 1, -1};



// Simple dfs call with Adjacency List
void dfs(vector<vector<int>>& g, vector<bool>& vis, int u) {

    cout<<u<<" ";

    vis[u] = true; // vis[i] = 1;
    for(auto child : g[u]) {
        if(!vis[child]) dfs(g, vis, child);
    }
}


// Checks cycle in Undirected Graph using DFS
bool cycleInUndirectedGraphDFS(vector<vector<int>>& g, vector<bool>& vis, int u, int par) {

    vis[u] = true;

    for(auto &child : g[u]) {
        // If child is not visited then we go and check in the 
        // following child and see if there is any cycle in the subtree ? 
        if(!vis[child]) {
            if(cycleInUndirectedGraphDFS(g, vis, child, u)) return true;
        }
        else if(child != par) return true;
        // Visited node must be equal to parent node otherwise it can be visited
        // only if there is a cycle
    }
    return false;
}


bool cycleInDirectedGraphDFS(vector<vector<int>>& g, vector<int>& vis, int u) {

    // Marking the current node as visited
    vis[u] = 1;

    bool ans = false;// Store the answer of every callable DFS calls
    for(auto &child : g[u]) {

        // If Child is already visited in the path that means there exist a cycle
        if(vis[child] == 1) return true;

        // Store the answer of all the remaining arrangement of the subtrees
        ans |= cycleInDirectedGraphDFS(g, vis, child);
    }
    return ans;
}

void topoSortDFS(vector<vector<int>>& g, vector<bool>& vis, int u, vector<int>& order) {

    // Marking the current node as visited
    vis[u] = 1;

    // Simple DFS calls
    for(auto &child : g[u]) {
        if(!vis[child]) topoSortDFS(g, vis, child, order);
    }

    // We can store the same result either in vector or stack
    order.emplace_back(u);
}

void topoSortDFS(vector<vector<int>>& g, vector<bool>& vis, int u, stack<int>& order) {

    // Marking the current node as visited
    vis[u] = 1;

    // Simple DFS calls
    for(auto &child : g[u]) {
        if(!vis[child]) topoSortDFS(g, vis, child, order);
    }

    // We can store the same result either in vector or stack
    order.push(u);
}

void bfs(vector<vector<int>>& g, int u) {

    int n = g.size(); // Total no of nodes;
    vector<bool> vis(n, false);
    queue<int> q;
    q.push(u); // Node from where we will start BFS
    vis[u] = true;

    while(!q.empty()) {

        int u = q.front();
        q.pop();
        //cout << u << " ";
        for(auto &child : g[u]) {
            if(!vis[child]) {
                vis[child] = true;
                q.push(child);
            }
        }
    }
}

void multiSourceBFS(vector<vector<int>>& g, vector<int>& start) {

    int n = g.size();
    vector<bool> vis(n, false);
    queue<int> q;

    for(int i = 0; i < start.size(); ++i) {
        q.push(start[i]);
        vis[start[i]] = true;
    }

    while(!q.empty()) {

        int u = q.front();
        q.pop();
        //cout << u << " ";
        for(auto &child : g[u]) {
            if(!vis[child]) {
                vis[child] = true;
                q.push(child);
            }
        }
    }

}


vector<int> khanAlgo(vector<vector<int>>& g, vector<int>& indegree) {

    int n = g.size();
    vector<bool> vis(n, false);
    queue<int> q;

    vector<int> ans;
    for(int i = 0; i < indegree.size(); ++i) {

        if(indegree[i] == 0) {
            vis[i] = true;
            q.push(i);
        }
    }

    while(!q.empty()) {

        int u = q.front();
        q.pop();
        ans.emplace_back(u);

        for(auto &child : g[u]) {
            if(!vis[child]) {
                indegree[child]--;
                if(indegree[child] == 0) {
                    q.push(child);
                    vis[child] = true;
                }
            }
        }
    }

    reverse(ans.begin(), ans.end());
    return ans;
}

void kosarajuAlgo(vector<vector<int>> &g) {

    // Can be used to get total no of strongly connected components

    int n = g.size();

    vector<bool> vis(n, false);
    stack<int> topoNodes;

    for(int i = 0; i < n; ++i) {
        if(!vis[i]) {
            topoSortDFS(g, vis, i, topoNodes);
        }
    }

    // Now reverse the Graph

    vector<vector<int>> newGraph(n);
    for(int i = 0; i < n; ++i) {
        vis[i] = false;
        for(int j = 0; j < g[i].size(); ++j) {
            newGraph[g[i][j]].emplace_back(i);
        }
    }

    int scc = 0;
    while(!topoNodes.empty()) {
        int u = topoNodes.top();
        topoNodes.pop();
        if(vis[u] == false) {

            scc++;
            dfs(newGraph, vis, u);
        }
    }

    cout << scc << endl;
    return;
}



void bellmanFord(vector<vector<int>> &edgeList, int n) {

    vector<int> dist(n, INT_MAX);

    // Remember when we are calculating min distance from the node
    // It all works in addition not multiplaction or exponential
    // for that type of things we have to break the problem in such a way
    // that it uses addition for calculating min dist
    // Or change the approach.


    bool ok = false;

    // We are relaxing the edge for n - 1 times
    // In the nth relaxation if relaxation is happens than we 
    // know that we have a cycle.
    for(int i = 0; i < n; ++i) {
        for(auto &edge : edgeList) {

            int a = edge[0];
            int b = edge[1];
            int w = edge[2];

            if(dist[a] != INT_MAX && dist[a] + w < dist[b]) {
                if(i == n - 1) ok = true;
                dist[b] = dist[a] + w;
            }
        }
    }

    if(ok) cout << "Negative Cycle";

    return;
}

void dfsOnGrid(vector<vector<int>> &g, vector<vector<bool>> &vis, int x, int y) {

    vis[x][y] = true;
    // cout << x << " " << y << "\n";

    for(int i = 0; i < 4; ++i) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if(nx >= 0 && ny >= 0 && nx < g.size() && ny < g[nx].size() && !vis[nx][ny] && g[nx][ny] == 1)
            dfsOnGrid(g, vis, nx, ny);
    }
}

void dfsOnGrid(vector<vector<int>> &g, int x, int y) {

    g[x][y] = 0;
    // cout << x << " " << y << "\n";

    for(int i = 0; i < 4; ++i) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if(nx >= 0 && ny >= 0 && nx < g.size() && ny < g[nx].size() && g[nx][ny] == 1)
            dfsOnGrid(g, nx, ny);
    }
}



// DSU


// Find / Get function
// Path compression technique is used here
// O(log*n) complexity
// Here we are just finding the parent and then while coming back
// we are updating the parent for the current node 
int Get(vector<int> &parent, int a) {

    return parent[a] = parent[a] == a ? a : Get(parent, parent[a]);
}


// Union by rank
void Union(vector<int> & parent, vecor<int> &rank, int a, int b) {

    a = Get(parent, a);
    b = Get(parent, b);
    if(a == b) return; // No need to merge the same components again || CYCLE !!!!
    if(rank[a] < rank[b]) swap(a, b); 
    parent[b] = a; // Updating the parent of other component
    rank[a] += rank[b]; // Updating the size of component's parent
}


signed main() {
    int t = 1;
    cin >> t;
    while(t--) {

        int n, m;
        cin >> n >> m;
        vector<vector<int>> g(n, vector<int>(m));
        for(int i = 0; i < n; ++i) {
            for(int j = 0; j < m; ++j) {
                cin >> g[i][j];
            }
        }
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        dfsOnGrid(g, 1, 1);
        // dfs(g, vis, 0LL);

        for(int i = 0; i < n; ++i) {
            for(int j = 0; j < m; ++j) {
                cout << g[i][j] << " ";
            }
            cout<<endl;
        }
        return 0;
    }
}
